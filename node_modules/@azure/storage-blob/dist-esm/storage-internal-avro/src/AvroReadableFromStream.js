import { __awaiter, __extends, __generator } from "tslib";
import { AvroReadable } from "./AvroReadable";
var AvroReadableFromStream = /** @class */ (function (_super) {
    __extends(AvroReadableFromStream, _super);
    // private _stillReadable: boolean;
    function AvroReadableFromStream(readable) {
        var _this = _super.call(this) || this;
        _this._readable = readable;
        _this._position = 0;
        return _this;
        // workaround due to Readable.readable only available after Node.js v11.4
        // this._stillReadable = true;
        // this._readable.on("end", () => {
        //   this._stillReadable = false;
        // });
        // this._readable.on("error", () => {
        //   this._stillReadable = false;
        // });
    }
    AvroReadableFromStream.prototype.toUint8Array = function (data) {
        if (typeof data === "string") {
            return Buffer.from(data);
        }
        return data;
    };
    Object.defineProperty(AvroReadableFromStream.prototype, "position", {
        get: function () {
            return this._position;
        },
        enumerable: false,
        configurable: true
    });
    AvroReadableFromStream.prototype.read = function (size) {
        return __awaiter(this, void 0, void 0, function () {
            var chunk;
            var _this = this;
            return __generator(this, function (_a) {
                // console.log(`reading stream for size ${size} at position ${this._position}`);
                if (size < 0) {
                    throw new Error("size parameter should be positive: " + size);
                }
                if (size === 0) {
                    return [2 /*return*/, new Uint8Array()];
                }
                // readable is true if it is safe to call readable.read(), which means the stream has not been destroyed or emitted 'error' or 'end'.
                // if (!this._stillReadable || this._readable.destroyed) {
                if (!this._readable.readable) {
                    throw new Error("Stream no longer readable.");
                }
                chunk = this._readable.read(size);
                if (chunk) {
                    this._position += chunk.length;
                    // chunk.length maybe less than desired size if the stream ends.
                    return [2 /*return*/, this.toUint8Array(chunk)];
                }
                else {
                    // register callback to wait for enough data to read
                    return [2 /*return*/, new Promise(function (resolve, reject) {
                            var readableCallback = function () {
                                var chunk = _this._readable.read(size);
                                if (chunk) {
                                    _this._position += chunk.length;
                                    _this._readable.removeListener("readable", readableCallback);
                                    _this._readable.removeListener("error", rejectCallback);
                                    _this._readable.removeListener("end", rejectCallback);
                                    _this._readable.removeListener("close", rejectCallback);
                                    // chunk.length maybe less than desired size if the stream ends.
                                    resolve(_this.toUint8Array(chunk));
                                }
                            };
                            var rejectCallback = function () {
                                _this._readable.removeListener("readable", readableCallback);
                                _this._readable.removeListener("error", rejectCallback);
                                _this._readable.removeListener("end", rejectCallback);
                                _this._readable.removeListener("close", rejectCallback);
                                reject();
                            };
                            _this._readable.on("readable", readableCallback);
                            _this._readable.once("error", rejectCallback);
                            _this._readable.once("end", rejectCallback);
                            _this._readable.once("close", rejectCallback);
                        })];
                }
                return [2 /*return*/];
            });
        });
    };
    return AvroReadableFromStream;
}(AvroReadable));
export { AvroReadableFromStream };
//# sourceMappingURL=AvroReadableFromStream.js.map