{"version":3,"file":"AvroParser.js","sourceRoot":"","sources":["../../../../storage-internal-avro/src/AvroParser.ts"],"names":[],"mappings":"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","sourcesContent":["import { AvroReadable } from \"./AvroReadable\";\nimport { KeyValuePair } from \"./utils/utils.common\";\n\nexport class AvroParser {\n  /**\n   * Reads a fixed number of bytes from the stream.\n   *\n   * @static\n   * @param stream\n   * @param length\n   */\n  public static async readFixedBytes(stream: AvroReadable, length: number): Promise<Uint8Array> {\n    const bytes = await stream.read(length);\n    if (bytes.length != length) {\n      throw new Error(\"Hit stream end.\");\n    }\n    return bytes;\n  }\n\n  /**\n   * Reads a single byte from the stream.\n   *\n   * @static\n   * @param stream\n   */\n  private static async readByte(stream: AvroReadable): Promise<number> {\n    const buf = await AvroParser.readFixedBytes(stream, 1);\n    return buf[0];\n  }\n\n  // int and long are stored in variable-length zig-zag coding.\n  // variable-length: https://lucene.apache.org/core/3_5_0/fileformats.html#VInt\n  // zig-zag: https://developers.google.com/protocol-buffers/docs/encoding?csw=1#types\n  private static async readZigZagLong(stream: AvroReadable): Promise<number> {\n    let zigZagEncoded = 0;\n    let significanceInBit = 0;\n    let byte, haveMoreByte, significanceInFloat;\n\n    do {\n      byte = await AvroParser.readByte(stream);\n      haveMoreByte = byte & 0x80;\n      zigZagEncoded |= (byte & 0x7f) << significanceInBit;\n      significanceInBit += 7;\n    } while (haveMoreByte && significanceInBit < 28); // bitwise operation only works for 32-bit integers\n\n    if (haveMoreByte) {\n      // Switch to float arithmetic\n      // FIXME: this only works when zigZagEncoded is no more than Number.MAX_SAFE_INTEGER (2**53 - 1)\n      zigZagEncoded = zigZagEncoded;\n      significanceInFloat = 268435456; // 2 ** 28.\n      do {\n        byte = await AvroParser.readByte(stream);\n        zigZagEncoded += (byte & 0x7f) * significanceInFloat;\n        significanceInFloat *= 128; // 2 ** 7\n      } while (byte & 0x80);\n      return (zigZagEncoded % 2 ? -(zigZagEncoded + 1) : zigZagEncoded) / 2;\n    }\n\n    return (zigZagEncoded >> 1) ^ -(zigZagEncoded & 1);\n  }\n\n  public static async readLong(stream: AvroReadable): Promise<number> {\n    return AvroParser.readZigZagLong(stream);\n  }\n\n  public static async readInt(stream: AvroReadable): Promise<number> {\n    return AvroParser.readZigZagLong(stream);\n  }\n\n  public static async readNull(): Promise<null> {\n    return null;\n  }\n\n  public static async readBoolean(stream: AvroReadable): Promise<Boolean> {\n    const b = await AvroParser.readByte(stream);\n    if (b == 1) {\n      return true;\n    } else if (b == 0) {\n      return false;\n    } else {\n      throw new Error(\"Byte was not a boolean.\");\n    }\n  }\n\n  public static async readFloat(stream: AvroReadable): Promise<number> {\n    const u8arr = await AvroParser.readFixedBytes(stream, 4);\n    const view = new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength);\n    return view.getFloat32(0, true); // littleEndian = true\n  }\n\n  public static async readDouble(stream: AvroReadable): Promise<number> {\n    const u8arr = await AvroParser.readFixedBytes(stream, 8);\n    const view = new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength);\n    return view.getFloat64(0, true); // littleEndian = true\n  }\n\n  public static async readBytes(stream: AvroReadable): Promise<Uint8Array> {\n    const size = await AvroParser.readLong(stream);\n    if (size < 0) {\n      throw new Error(\"Bytes size was negative.\");\n    }\n\n    return await stream.read(size);\n  }\n\n  public static async readString(stream: AvroReadable): Promise<string> {\n    const u8arr = await AvroParser.readBytes(stream);\n\n    // polyfill TextDecoder to be backward compatible with older\n    // nodejs that doesn't expose TextDecoder as a global variable\n    if (typeof TextDecoder === \"undefined\" && typeof require !== \"undefined\") {\n      (global as any).TextDecoder = require(\"util\").TextDecoder;\n    }\n\n    // FIXME: need TextDecoder polyfill for IE\n    let utf8decoder = new TextDecoder();\n    return utf8decoder.decode(u8arr);\n  }\n\n  private static async readMapPair<T>(\n    stream: AvroReadable,\n    readItemMethod: (s: AvroReadable) => Promise<T>\n  ): Promise<KeyValuePair<T>> {\n    const key = await AvroParser.readString(stream);\n    // FIXME: what about readFixed which need a length as parameter.\n    const value = await readItemMethod(stream);\n    return { key, value };\n  }\n\n  public static async readMap<T>(\n    stream: AvroReadable,\n    readItemMethod: (s: AvroReadable) => Promise<T>\n  ): Promise<Record<string, T>> {\n    const readPairMethod = async (stream: AvroReadable): Promise<KeyValuePair<T>> => {\n      return await AvroParser.readMapPair(stream, readItemMethod);\n    };\n\n    const pairs: KeyValuePair<T>[] = await AvroParser.readArray(stream, readPairMethod);\n    let dict: Record<string, T> = {};\n    for (const pair of pairs) {\n      dict[pair.key] = pair.value;\n    }\n    return dict;\n  }\n\n  private static async readArray<T>(\n    stream: AvroReadable,\n    readItemMethod: (s: AvroReadable) => Promise<T>\n  ): Promise<T[]> {\n    let items: T[] = [];\n    for (\n      let count = await AvroParser.readLong(stream);\n      count != 0;\n      count = await AvroParser.readLong(stream)\n    ) {\n      if (count < 0) {\n        // Ignore block sizes\n        await AvroParser.readLong(stream);\n        count = -count;\n      }\n\n      while (count--) {\n        const item: T = await readItemMethod(stream);\n        items.push(item);\n      }\n    }\n    return items;\n  }\n}\n\ninterface RecordField {\n  name: string;\n  type: string | ObjectSchema | (string | ObjectSchema)[]; // Unions may not immediately contain other unions.\n}\n\nenum AvroComplex {\n  RECORD = \"record\",\n  ENUM = \"enum\",\n  ARRAY = \"array\",\n  MAP = \"map\",\n  UNION = \"union\",\n  FIXED = \"fixed\"\n}\n\ninterface ObjectSchema {\n  type: Exclude<AvroComplex, AvroComplex.UNION>;\n  name?: string;\n  aliases?: string;\n  fields?: RecordField[];\n  symbols?: string[];\n  values?: string;\n  size?: number;\n}\n\nexport abstract class AvroType {\n  /**\n   * Reads an object from the stream.\n   *\n   * @param stream\n   */\n  public abstract read(stream: AvroReadable): Promise<Object | null>;\n\n  /**\n   * Determines the AvroType from the Avro Schema.\n   */\n  public static fromSchema(schema: string | Object): AvroType {\n    if (typeof schema == \"string\") {\n      return AvroType.fromStringSchema(schema);\n    } else if (Array.isArray(schema)) {\n      return AvroType.fromArraySchema(schema);\n    } else {\n      return AvroType.fromObjectSchema(schema as ObjectSchema);\n    }\n  }\n\n  private static fromStringSchema(schema: string): AvroType {\n    // FIXME: simpler way to tell if schema is of type AvroPrimitive?\n    switch (schema) {\n      case AvroPrimitive.NULL:\n      case AvroPrimitive.BOOLEAN:\n      case AvroPrimitive.INT:\n      case AvroPrimitive.LONG:\n      case AvroPrimitive.FLOAT:\n      case AvroPrimitive.DOUBLE:\n      case AvroPrimitive.BYTES:\n      case AvroPrimitive.STRING:\n        return new AvroPrimitiveType(schema as AvroPrimitive);\n      default:\n        throw new Error(`Unexpected Avro type ${schema}`);\n    }\n  }\n\n  private static fromArraySchema(schema: any[]): AvroType {\n    return new AvroUnionType(schema.map(AvroType.fromSchema));\n  }\n\n  private static fromObjectSchema(schema: ObjectSchema): AvroType {\n    const type = schema.type;\n    // Primitives can be defined as strings or objects\n    try {\n      return AvroType.fromStringSchema(type);\n    } catch (err) {}\n\n    switch (type) {\n      case AvroComplex.RECORD:\n        if (schema.aliases) {\n          throw new Error(`aliases currently is not supported, schema: ${schema}`);\n        }\n        if (!schema.name) {\n          throw new Error(`Required attribute 'name' doesn't exist on schema: ${schema}`);\n        }\n\n        let fields: Record<string, AvroType> = {};\n        if (!schema.fields) {\n          throw new Error(`Required attribute 'fields' doesn't exist on schema: ${schema}`);\n        }\n        for (const field of schema.fields) {\n          fields[field.name] = AvroType.fromSchema(field.type);\n        }\n        return new AvroRecordType(fields, schema.name);\n      case AvroComplex.ENUM:\n        if (schema.aliases) {\n          throw new Error(`aliases currently is not supported, schema: ${schema}`);\n        }\n        if (!schema.symbols) {\n          throw new Error(`Required attribute 'symbols' doesn't exist on schema: ${schema}`);\n        }\n        return new AvroEnumType(schema.symbols);\n      case AvroComplex.MAP:\n        if (!schema.values) {\n          throw new Error(`Required attribute 'values' doesn't exist on schema: ${schema}`);\n        }\n        return new AvroMapType(AvroType.fromSchema(schema.values));\n      case AvroComplex.ARRAY: // Unused today\n      case AvroComplex.FIXED: // Unused today\n      default:\n        throw new Error(`Unexpected Avro type ${type} in ${schema}`);\n    }\n  }\n}\n\nenum AvroPrimitive {\n  NULL = \"null\",\n  BOOLEAN = \"boolean\",\n  INT = \"int\",\n  LONG = \"long\",\n  FLOAT = \"float\",\n  DOUBLE = \"double\",\n  BYTES = \"bytes\",\n  STRING = \"string\"\n}\n\nclass AvroPrimitiveType extends AvroType {\n  private _primitive: AvroPrimitive;\n\n  constructor(primitive: AvroPrimitive) {\n    super();\n    this._primitive = primitive;\n  }\n\n  public async read(stream: AvroReadable): Promise<Object | null> {\n    switch (this._primitive) {\n      case AvroPrimitive.NULL:\n        return await AvroParser.readNull();\n      case AvroPrimitive.BOOLEAN:\n        return await AvroParser.readBoolean(stream);\n      case AvroPrimitive.INT:\n        return await AvroParser.readInt(stream);\n      case AvroPrimitive.LONG:\n        return await AvroParser.readLong(stream);\n      case AvroPrimitive.FLOAT:\n        return await AvroParser.readFloat(stream);\n      case AvroPrimitive.DOUBLE:\n        return await AvroParser.readDouble(stream);\n      case AvroPrimitive.BYTES:\n        return await AvroParser.readBytes(stream);\n      case AvroPrimitive.STRING:\n        return await AvroParser.readString(stream);\n      default:\n        throw new Error(\"Unknown Avro Primitive\");\n    }\n  }\n}\n\nclass AvroEnumType extends AvroType {\n  private readonly _symbols: string[];\n\n  constructor(symbols: string[]) {\n    super();\n    this._symbols = symbols;\n  }\n\n  public async read(stream: AvroReadable): Promise<Object> {\n    const value = await AvroParser.readInt(stream);\n    return this._symbols[value];\n  }\n}\n\nclass AvroUnionType extends AvroType {\n  private readonly _types: AvroType[];\n\n  constructor(types: AvroType[]) {\n    super();\n    this._types = types;\n  }\n\n  public async read(stream: AvroReadable): Promise<Object | null> {\n    const typeIndex = await AvroParser.readInt(stream);\n    return await this._types[typeIndex].read(stream);\n  }\n}\n\nclass AvroMapType extends AvroType {\n  private readonly _itemType: AvroType;\n\n  constructor(itemType: AvroType) {\n    super();\n    this._itemType = itemType;\n  }\n\n  public async read(stream: AvroReadable): Promise<Object> {\n    const readItemMethod = async (s: AvroReadable): Promise<Object | null> => {\n      return await this._itemType.read(s);\n    };\n    return await AvroParser.readMap(stream, readItemMethod);\n  }\n}\n\nclass AvroRecordType extends AvroType {\n  private readonly _name: string;\n  private readonly _fields: Record<string, AvroType>;\n\n  constructor(fields: Record<string, AvroType>, name: string) {\n    super();\n    this._fields = fields;\n    this._name = name;\n  }\n\n  public async read(stream: AvroReadable): Promise<Object> {\n    let record: Record<string, Object | null> = {};\n    //  FIXME: what for?\n    record[\"$schema\"] = this._name;\n    for (const key in this._fields) {\n      if (this._fields.hasOwnProperty(key)) {\n        record[key] = await this._fields[key].read(stream);\n      }\n    }\n    return record;\n  }\n}\n"]}