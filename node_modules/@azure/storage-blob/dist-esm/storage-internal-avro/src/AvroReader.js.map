{"version":3,"file":"AvroReader.js","sourceRoot":"","sources":["../../../../storage-internal-avro/src/AvroReader.ts"],"names":[],"mappings":";AACA,OAAO,EACL,qBAAqB,EACrB,eAAe,EACf,cAAc,EACd,eAAe,EAChB,MAAM,iBAAiB,CAAC;AACzB,OAAO,EAAE,WAAW,EAAE,MAAM,sBAAsB,CAAC;AACnD,OAAO,EAAE,QAAQ,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AACpD,OAAO,oBAAoB,CAAC;AAE5B;IAoCE,oBACE,UAAwB,EACxB,YAA2B,EAC3B,kBAA2B,EAC3B,uBAAgC;QAEhC,IAAI,CAAC,WAAW,GAAG,UAAU,CAAC;QAC9B,IAAI,CAAC,aAAa,GAAG,YAAY,IAAI,UAAU,CAAC;QAChD,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;QAC1B,IAAI,CAAC,YAAY,GAAG,kBAAkB,IAAI,CAAC,CAAC;QAC5C,IAAI,CAAC,YAAY,GAAG,uBAAuB,IAAI,CAAC,CAAC;IACnD,CAAC;IA/BD,sBAAW,mCAAW;aAAtB;YACE,OAAO,IAAI,CAAC,YAAY,CAAC;QAC3B,CAAC;;;OAAA;IAGD,sBAAW,mCAAW;aAAtB;YACE,OAAO,IAAI,CAAC,YAAY,CAAC;QAC3B,CAAC;;;OAAA;IA0BD,kCAAkC;IACpB,+BAAU,GAAxB;;;;;4BACiB,qBAAM,UAAU,CAAC,cAAc,CAAC,IAAI,CAAC,aAAa,EAAE,eAAe,CAAC,MAAM,CAAC,EAAA;;wBAApF,MAAM,GAAG,SAA2E;wBAC1F,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE,eAAe,CAAC,EAAE;4BACzC,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;yBAChD;wBAED,sEAAsE;wBACtE,sCAAsC;wBACtC,KAAA,IAAI,CAAA;wBAAa,qBAAM,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,EAAE,UAAU,CAAC,UAAU,CAAC,EAAA;;wBAFpF,sEAAsE;wBACtE,sCAAsC;wBACtC,GAAK,SAAS,GAAG,SAAmE,CAAC;wBAG/E,KAAK,GAAG,IAAI,CAAC,SAAU,CAAC,cAAc,CAAC,CAAC;wBAC9C,IAAI,CAAC,CAAC,KAAK,IAAI,SAAS,IAAI,KAAK,IAAI,MAAM,CAAC,EAAE;4BAC5C,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;yBAC7C;wBAED,6DAA6D;wBAC7D,KAAA,IAAI,CAAA;wBAAe,qBAAM,UAAU,CAAC,cAAc,CAAC,IAAI,CAAC,aAAa,EAAE,qBAAqB,CAAC,EAAA;;wBAD7F,6DAA6D;wBAC7D,GAAK,WAAW,GAAG,SAA0E,CAAC;wBAGxF,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAU,CAAC,eAAe,CAAC,CAAC,CAAC;wBAC5D,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;wBAE7C,IAAI,IAAI,CAAC,YAAY,IAAI,CAAC,EAAE;4BAC1B,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC;yBAC/C;wBAED,KAAA,IAAI,CAAA;wBAA0B,qBAAM,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,EAAA;;wBAAzE,GAAK,sBAAsB,GAAG,SAA2C,CAAC;wBAC1E,oBAAoB;wBACpB,qBAAM,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,EAAA;;wBAD3C,oBAAoB;wBACpB,SAA2C,CAAC;wBAE5C,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;6BACrB,CAAA,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC,YAAY,GAAG,CAAC,CAAA,EAA1C,wBAA0C;wBACnC,CAAC,GAAG,CAAC;;;6BAAE,CAAA,CAAC,GAAG,IAAI,CAAC,YAAY,CAAA;wBACnC,qBAAM,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,EAAA;;wBAA3C,SAA2C,CAAC;wBAC5C,IAAI,CAAC,sBAAuB,EAAE,CAAC;;;wBAFM,CAAC,EAAE,CAAA;;;;;;KAK7C;IAEM,4BAAO,GAAd;QACE,OAAO,CAAC,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC,sBAAuB,GAAG,CAAC,CAAC;IAChE,CAAC;IAEa,iCAAY,GAA1B;;;;;;6BACM,CAAC,IAAI,CAAC,YAAY,EAAlB,wBAAkB;wBACpB,6BAAM,IAAI,CAAC,UAAU,EAAE,GAAA;;wBAAvB,SAAuB,CAAC;;;6BAGnB,IAAI,CAAC,OAAO,EAAE;wBACJ,6BAAM,IAAI,CAAC,SAAU,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,GAAA;;wBAArD,MAAM,GAAG,SAA4C;wBAE3D,IAAI,CAAC,sBAAuB,EAAE,CAAC;wBAC/B,IAAI,CAAC,YAAa,EAAE,CAAC;6BAEjB,CAAA,IAAI,CAAC,sBAAsB,IAAI,CAAC,CAAA,EAAhC,yBAAgC;wBACnB,6BAAM,UAAU,CAAC,cAAc,CAAC,IAAI,CAAC,WAAW,EAAE,qBAAqB,CAAC,GAAA;;wBAAjF,MAAM,GAAG,SAAwE;wBAEvF,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC;wBAC9C,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC;wBAEtB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,WAAY,EAAE,MAAM,CAAC,EAAE;4BAC3C,MAAM,IAAI,KAAK,CAAC,kCAAkC,CAAC,CAAC;yBACrD;;;;wBAGC,KAAA,IAAI,CAAA;wBAA0B,6BAAM,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,GAAA;;wBAAzE,GAAK,sBAAsB,GAAG,SAA2C,CAAC;;;;wBAE1E,gCAAgC;wBAChC,IAAI,CAAC,sBAAsB,GAAG,CAAC,CAAC;;;6BAG9B,CAAA,IAAI,CAAC,sBAAuB,GAAG,CAAC,CAAA,EAAhC,yBAAgC;wBAClC,oBAAoB;wBACpB,6BAAM,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,GAAA;;wBAD3C,oBAAoB;wBACpB,SAA2C,CAAC;;0DAG1C,MAAM;6BAAZ,gCAAY;;wBAAZ,SAAY,CAAC;;;;;;KAEhB;IACH,iBAAC;AAAD,CAAC,AAlID,IAkIC","sourcesContent":["import { AvroReadable } from \"./AvroReadable\";\nimport {\n  AVRO_SYNC_MARKER_SIZE,\n  AVRO_INIT_BYTES,\n  AVRO_CODEC_KEY,\n  AVRO_SCHEMA_KEY\n} from \"./AvroConstants\";\nimport { arraysEqual } from \"./utils/utils.common\";\nimport { AvroType, AvroParser } from \"./AvroParser\";\nimport \"@azure/core-paging\";\n\nexport class AvroReader {\n  private readonly _dataStream: AvroReadable;\n\n  private readonly _headerStream: AvroReadable;\n\n  private _syncMarker?: Uint8Array;\n\n  private _metadata?: Record<string, string>;\n\n  private _itemType?: AvroType;\n\n  private _itemsRemainingInBlock?: number;\n\n  /// The byte offset within the Avro file (both header and data)\n  /// of the start of the current block.\n  private _blockOffset: number;\n  public get blockOffset(): number {\n    return this._blockOffset;\n  }\n\n  private _objectIndex: number;\n  public get objectIndex(): number {\n    return this._objectIndex;\n  }\n\n  private _initialized: boolean;\n\n  constructor(dataStream: AvroReadable);\n\n  constructor(\n    dataStream: AvroReadable,\n    headerStream: AvroReadable,\n    currentBlockOffset: number,\n    indexWithinCurrentBlock: number\n  );\n\n  constructor(\n    dataStream: AvroReadable,\n    headerStream?: AvroReadable,\n    currentBlockOffset?: number,\n    indexWithinCurrentBlock?: number\n  ) {\n    this._dataStream = dataStream;\n    this._headerStream = headerStream || dataStream;\n    this._initialized = false;\n    this._blockOffset = currentBlockOffset || 0;\n    this._objectIndex = indexWithinCurrentBlock || 0;\n  }\n\n  // FUTURE: cancellation / aborter?\n  private async initialize() {\n    const header = await AvroParser.readFixedBytes(this._headerStream, AVRO_INIT_BYTES.length);\n    if (!arraysEqual(header, AVRO_INIT_BYTES)) {\n      throw new Error(\"Stream is not an Avro file.\");\n    }\n\n    // File metadata is written as if defined by the following map schema:\n    // { \"type\": \"map\", \"values\": \"bytes\"}\n    this._metadata = await AvroParser.readMap(this._headerStream, AvroParser.readString);\n\n    // Validate codec\n    const codec = this._metadata![AVRO_CODEC_KEY];\n    if (!(codec == undefined || codec == \"null\")) {\n      throw new Error(\"Codecs are not supported\");\n    }\n\n    // The 16-byte, randomly-generated sync marker for this file.\n    this._syncMarker = await AvroParser.readFixedBytes(this._headerStream, AVRO_SYNC_MARKER_SIZE);\n\n    // Parse the schema\n    const schema = JSON.parse(this._metadata![AVRO_SCHEMA_KEY]);\n    this._itemType = AvroType.fromSchema(schema);\n\n    if (this._blockOffset == 0) {\n      this._blockOffset = this._dataStream.position;\n    }\n\n    this._itemsRemainingInBlock = await AvroParser.readLong(this._dataStream);\n    // skip block length\n    await AvroParser.readLong(this._dataStream);\n\n    this._initialized = true;\n    if (this._objectIndex && this._objectIndex > 0) {\n      for (let i = 0; i < this._objectIndex; i++) {\n        await this._itemType.read(this._dataStream);\n        this._itemsRemainingInBlock!--;\n      }\n    }\n  }\n\n  public hasNext(): boolean {\n    return !this._initialized || this._itemsRemainingInBlock! > 0;\n  }\n\n  public async *parseObjects(): AsyncIterableIterator<Record<string, any> | null> {\n    if (!this._initialized) {\n      await this.initialize();\n    }\n\n    while (this.hasNext()) {\n      const result = await this._itemType!.read(this._dataStream);\n\n      this._itemsRemainingInBlock!--;\n      this._objectIndex!++;\n\n      if (this._itemsRemainingInBlock == 0) {\n        const marker = await AvroParser.readFixedBytes(this._dataStream, AVRO_SYNC_MARKER_SIZE);\n\n        this._blockOffset = this._dataStream.position;\n        this._objectIndex = 0;\n\n        if (!arraysEqual(this._syncMarker!, marker)) {\n          throw new Error(\"Stream is not a valid Avro file.\");\n        }\n\n        try {\n          this._itemsRemainingInBlock = await AvroParser.readLong(this._dataStream);\n        } catch (err) {\n          // We hit the end of the stream.\n          this._itemsRemainingInBlock = 0;\n        }\n\n        if (this._itemsRemainingInBlock! > 0) {\n          // Ignore block size\n          await AvroParser.readLong(this._dataStream);\n        }\n      }\n      yield result;\n    }\n  }\n}\n"]}